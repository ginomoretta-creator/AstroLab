import React, { useState, useEffect, useRef } from 'react';
import { RefreshCw, Zap, Activity, Layers, Settings, ArrowRight, CheckCircle, MousePointer2, AlertTriangle, Crosshair, BrainCircuit, Orbit } from 'lucide-react';
import * as THREE from 'three';

/**
 * CONSTANTES & FISICA (CR3BP)
 * Sistema Normalizado para el Marco Rotante
 */
const EARTH_R = 0.6; 
const MOON_R = 0.2;  
const MOON_DIST = 38; 
const INITIAL_SEGMENTS = 1200; 
const BATCH_SIZE = 40;

// Colores temáticos
const COLORS = {
  bg: '#0f172a',
  thrust: '#ef4444', 
  coast: '#3b82f6', 
  moonOrbit: '#10b981', 
  grid: '#334155',
  error: '#f59e0b',
  ghost: '#475569'
};

const MISSION_PRESETS = {
    DEFAULT: { mass: 1000, thrust: 0.5, isp: 2000, initialRadius: 2000 },
    HEAVY_CARGO: { mass: 4500, thrust: 1.5, isp: 1800, initialRadius: 1000 },
    FAST_SCOUT: { mass: 200, thrust: 0.3, isp: 3000, initialRadius: 5000 },
    DEEP_SPACE: { mass: 1500, thrust: 0.2, isp: 4500, initialRadius: 8000 }
};

/**
 * MOTOR FÍSICO CR3BP (ROTATING FRAME)
 * Incluye Gravedad N-Cuerpos + Coriolis + Centrífuga + Protecciones Numéricas
 */
const simulateTrajectory = (schedule, config, steeringProfile) => {
  const points = [];
  const { initialRadius, thrust, mass } = config;
  
  // 1. Definición del Sistema
  const MU_EARTH = 8000; 
  const MU_MOON = 120; 
  
  // Softening: Evita división por cero en el centro de los planetas
  const SOFTENING = 0.1; 

  const omega = Math.sqrt((MU_EARTH + MU_MOON) / Math.pow(MOON_DIST, 3));
  const THRUST_SCALE = 1.2; 
  const accelBase = (thrust / mass) * THRUST_SCALE;

  // Estado Inicial
  let r = 1.0 + (initialRadius / 8000); 
  let x = r; 
  let y = 0;
  
  const vInertial = Math.sqrt(MU_EARTH / r) * 0.012;
  let vx = 0; 
  let vy = vInertial - (omega * r); 

  let closestDist = Infinity;
  let captured = false;
  let stableOrbits = 0;
  let lastMoonAngle = 0;

  const len = schedule.length;
  const dt = 0.5; 
  const MAX_VEL = 10.0; // Límite de velocidad para evitar explosiones numéricas
  const MAX_DIST = 200; // Límite de distancia

  for (let i = 0; i < len; i++) {
    // Check de seguridad previo
    if (!Number.isFinite(x) || !Number.isFinite(y) || Math.abs(x) > MAX_DIST || Math.abs(y) > MAX_DIST) {
        break; // Abortar trayectoria si escapa o se corrompe
    }

    const isThrusting = schedule[i] === 1;
    
    // 1. Distancias con Softening
    const r2 = x*x + y*y;
    const rMag = Math.sqrt(r2);
    const distEarthSq = r2 + SOFTENING; 
    
    const dxMoon = x - MOON_DIST;
    const dyMoon = y;
    const rMoon2 = dxMoon*dxMoon + dyMoon*dyMoon;
    const rMoon = Math.sqrt(rMoon2);
    const distMoonSq = rMoon2 + SOFTENING;

    // 2. Fuerzas Gravitacionales
    const axGrav = - (MU_EARTH * 0.0001 * x) / Math.pow(distEarthSq, 1.5) - (MU_MOON * 0.0001 * dxMoon) / Math.pow(distMoonSq, 1.5);
    const ayGrav = - (MU_EARTH * 0.0001 * y) / Math.pow(distEarthSq, 1.5) - (MU_MOON * 0.0001 * dyMoon) / Math.pow(distMoonSq, 1.5);

    // 3. Fuerzas Inerciales
    const axCen = omega * omega * x;
    const ayCen = omega * omega * y;
    const axCor = 2 * omega * vy;
    const ayCor = -2 * omega * vx;

    // 4. Empuje
    let axThrust = 0;
    let ayThrust = 0;
    if (isThrusting) {
        const vAngle = Math.atan2(vy, vx);
        const steer = steeringProfile ? steeringProfile[i] : 0;
        const totalAngle = vAngle + steer;
        
        axThrust = accelBase * Math.cos(totalAngle);
        ayThrust = accelBase * Math.sin(totalAngle);
    }

    // 5. Integración
    const axTotal = axGrav + axCen + axCor + axThrust;
    const ayTotal = ayGrav + ayCen + ayCor + ayThrust;

    vx += axTotal * dt;
    vy += ayTotal * dt;

    // Clamping de Velocidad (Safety)
    const vMagSq = vx*vx + vy*vy;
    if (vMagSq > MAX_VEL * MAX_VEL) {
        const scale = MAX_VEL / Math.sqrt(vMagSq);
        vx *= scale;
        vy *= scale;
    }

    vx *= 0.99995; // Damping
    vy *= 0.99995;

    x += vx * dt;
    y += vy * dt;

    // Colisión Tierra (Hard Floor)
    if (rMag < 0.7) { 
        const ang = Math.atan2(y, x);
        x = 0.7 * Math.cos(ang); y = 0.7 * Math.sin(ang);
        vx *= 0.5; vy *= 0.5;
    }

    const isMoonDominated = rMoon < 3.0;
    
    // Guardar solo si es válido
    if (Number.isFinite(x) && Number.isFinite(y)) {
        points.push({ x, y, isMoonDominated });
    }

    // Detección de Captura
    if (rMoon < closestDist) closestDist = rMoon;
    
    if (rMoon < 2.2) {
        const vRel2 = vx*vx + vy*vy;
        const energyMoon = 0.5 * vRel2 - (MU_MOON * 0.0001) / rMoon;
        
        if (energyMoon < 0) {
            captured = true;
            const moonAngle = Math.atan2(dyMoon, dxMoon);
            if (Math.abs(moonAngle - lastMoonAngle) > 3) stableOrbits++;
            lastMoonAngle = moonAngle;
        }
    }
  }
  
  // Fallback para evitar arrays vacíos
  if (points.length === 0) points.push({x: r, y: 0, isMoonDominated: false});

  return { points, closestDist, captured, stableOrbits };
};

/**
 * ESCENA 3D
 */
const Scene2D = ({ bestTrajectory, ghostTrajectories }) => {
  const mountRef = useRef(null);
  const rendererRef = useRef(null);
  const ghostsGroupRef = useRef(null);
  const trajGroupRef = useRef(null);

  useEffect(() => {
    if (!mountRef.current) return;
    const w = mountRef.current.clientWidth;
    const h = mountRef.current.clientHeight;
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(COLORS.bg);

    const camera = new THREE.OrthographicCamera(-55 * (w/h), 55 * (w/h), 55, -55, 1, 1000);
    camera.position.set(20, 0, 50); camera.lookAt(20, 0, 0);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(w, h);
    mountRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    const grid = new THREE.GridHelper(150, 30, COLORS.grid, '#1e293b');
    grid.rotation.x = Math.PI / 2; scene.add(grid);

    // Tierra
    const earthGroup = new THREE.Group();
    earthGroup.add(new THREE.Mesh(new THREE.CircleGeometry(EARTH_R * 2, 32), new THREE.MeshBasicMaterial({ color: '#3b82f6' })));
    earthGroup.add(new THREE.Mesh(new THREE.CircleGeometry(EARTH_R * 6, 32), new THREE.MeshBasicMaterial({ color: '#3b82f6', transparent: true, opacity: 0.1 })));
    scene.add(earthGroup);

    // Luna
    const moonGroup = new THREE.Group();
    moonGroup.position.set(MOON_DIST, 0, 0);
    moonGroup.add(new THREE.Mesh(new THREE.CircleGeometry(MOON_R * 3, 32), new THREE.MeshBasicMaterial({ color: '#94a3b8' })));
    moonGroup.add(new THREE.Mesh(new THREE.RingGeometry(2.0, 2.2, 32), new THREE.MeshBasicMaterial({ color: COLORS.moonOrbit, transparent: true, opacity: 0.3, side: THREE.DoubleSide })));
    moonGroup.add(new THREE.Mesh(new THREE.CircleGeometry(4.5, 32), new THREE.MeshBasicMaterial({ color: '#94a3b8', transparent: true, opacity: 0.05 })));
    scene.add(moonGroup);

    const ghostsGroup = new THREE.Group(); scene.add(ghostsGroup); ghostsGroupRef.current = ghostsGroup;
    const trajGroup = new THREE.Group(); scene.add(trajGroup); trajGroupRef.current = trajGroup;

    const animate = () => { renderer.render(scene, camera); requestAnimationFrame(animate); };
    animate();

    const handleResize = () => {
        if(!mountRef.current) return;
        const w = mountRef.current.clientWidth; const h = mountRef.current.clientHeight; const asp = w/h;
        camera.left = -55 * asp; camera.right = 55 * asp; camera.updateProjectionMatrix(); renderer.setSize(w, h);
    };
    window.addEventListener('resize', handleResize);
    return () => { if(mountRef.current && rendererRef.current) mountRef.current.removeChild(rendererRef.current.domElement); renderer.dispose(); };
  }, []);

  // Render Ghosts
  useEffect(() => {
      if (!ghostsGroupRef.current) return;
      const group = ghostsGroupRef.current;
      while(group.children.length > 0) group.remove(group.children[0]);
      
      ghostTrajectories.forEach((traj, idx) => {
          if (idx % 3 !== 0) return; 
          // Doble verificación de seguridad
          const validPoints = traj.points.filter(p => Number.isFinite(p.x) && Number.isFinite(p.y));
          if (validPoints.length < 2) return;

          const pts = validPoints.map(p => new THREE.Vector3(p.x, p.y, 0));
          // Try-catch para BufferGeometry por si acaso
          try {
            const geo = new THREE.BufferGeometry().setFromPoints(pts);
            group.add(new THREE.Line(geo, new THREE.LineBasicMaterial({ color: COLORS.ghost, opacity: 0.15, transparent: true })));
          } catch(e) { console.warn("Ghost geom error ignored"); }
      });
  }, [ghostTrajectories]);

  // Render Best
  useEffect(() => {
      if (!trajGroupRef.current || !bestTrajectory) return;
      const group = trajGroupRef.current;
      while(group.children.length > 0) group.remove(group.children[0]);

      const validPoints = bestTrajectory.points.filter(p => Number.isFinite(p.x) && Number.isFinite(p.y));
      if (validPoints.length < 2) return;

      const transferPts = [];
      const capturePts = [];
      
      validPoints.forEach(p => {
          const v = new THREE.Vector3(p.x, p.y, 0);
          if (p.isMoonDominated) capturePts.push(v);
          else transferPts.push(v);
          if (p.isMoonDominated && transferPts.length > 0 && transferPts[transferPts.length-1] !== v) transferPts.push(v);
      });

      try {
        if (transferPts.length > 0) group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(transferPts), new THREE.LineBasicMaterial({ color: COLORS.coast, linewidth: 2 })));
        if (capturePts.length > 0) group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(capturePts), new THREE.LineBasicMaterial({ color: COLORS.moonOrbit, linewidth: 2 })));
      } catch (e) { console.warn("Best traj geom error ignored"); }

  }, [bestTrajectory]);

  return <div ref={mountRef} className="w-full h-full" />;
};

const SliderControl = ({ label, value, min, max, step, unit, onChange, disabled }) => (
    <div className="mb-3 opacity-90">
        <div className="flex justify-between text-xs mb-1 text-slate-400 font-mono"><span>{label}</span><span className="text-white">{value} {unit}</span></div>
        <input type="range" min={min} max={max} step={step} value={value} onChange={(e) => onChange(parseFloat(e.target.value))} disabled={disabled} className="w-full h-1 bg-slate-700 rounded-lg appearance-none cursor-pointer disabled:cursor-not-allowed disabled:opacity-50 accent-blue-500 hover:accent-blue-400" />
    </div>
);

const App = () => {
  const [config, setConfig] = useState(MISSION_PRESETS.DEFAULT);
  const [segments, setSegments] = useState(INITIAL_SEGMENTS);
  
  const [bestSchedule, setBestSchedule] = useState(null);
  const [bestSteering, setBestSteering] = useState(null);
  const [bestResult, setBestResult] = useState(null);
  const [ghosts, setGhosts] = useState([]); 
  
  const [phase, setPhase] = useState('IDLE'); 
  const [generation, setGeneration] = useState(0);
  const [bestScore, setBestScore] = useState(Infinity);

  useEffect(() => {
      const initialSched = Array(segments).fill(0).map(() => Math.random() > 0.5 ? 1 : 0);
      const initialSteer = new Float32Array(segments).fill(0);
      setBestSchedule(initialSched); setBestSteering(initialSteer);
      setBestResult(simulateTrajectory(initialSched, config, initialSteer));
  }, [config]); 

  useEffect(() => {
      if (phase !== 'RUNNING') return;
      const evolve = () => {
          const population = [];
          population.push({ schedule: [...bestSchedule], steering: new Float32Array(bestSteering) });

          for (let i = 0; i < BATCH_SIZE; i++) {
              const mutSched = [...bestSchedule];
              const mutSteer = new Float32Array(bestSteering);
              const mutationRate = Math.max(0.02, 0.4 * Math.exp(-generation / 40)); 
              
              for (let j = 0; j < segments; j++) {
                  if (Math.random() < mutationRate) mutSched[j] = 1 - mutSched[j];
                  if (Math.random() < mutationRate) {
                      mutSteer[j] += (Math.random() - 0.5) * 0.6; 
                      mutSteer[j] = Math.max(-1.0, Math.min(1.0, mutSteer[j]));
                  }
              }
              population.push({ schedule: mutSched, steering: mutSteer });
          }

          const results = population.map(ind => {
              const res = simulateTrajectory(ind.schedule, config, ind.steering);
              let cost = 0;
              cost += res.closestDist * 100;
              if (!res.captured) cost += 1000; else cost -= 500;
              const pointsInMoonWell = res.points.filter(p => p.isMoonDominated).length;
              cost -= pointsInMoonWell * 3; 
              return { ...ind, result: res, cost };
          });

          results.sort((a, b) => a.cost - b.cost);
          const winner = results[0];

          setBestSchedule(winner.schedule); setBestSteering(winner.steering);
          setBestResult(winner.result); setBestScore(winner.cost);
          setGhosts(results.slice(1, 8).map(r => r.result)); 

          if (generation > 40 && !winner.result.captured && segments < 2000) {
             setSegments(s => s + 100);
             setBestSchedule(s => [...s, ...Array(100).fill(0)]);
             setBestSteering(s => { const n = new Float32Array(s.length + 100); n.set(s); return n; });
          }

          if (winner.result.captured && winner.result.stableOrbits >= 1 && generation > 100) {
              setPhase('CONVERGED');
          } else {
              setGeneration(g => g + 1);
          }
      };
      const timer = setTimeout(evolve, 0); 
      return () => clearTimeout(timer);
  }, [phase, generation, bestSchedule, bestSteering, segments, config]);

  const handleStart = () => { setPhase('RUNNING'); setGeneration(0); };
  const handleReset = () => {
    setPhase('IDLE'); setGeneration(0); setSegments(INITIAL_SEGMENTS);
    const s = Array(INITIAL_SEGMENTS).fill(0).map(() => Math.random() > 0.5 ? 1 : 0);
    const st = new Float32Array(INITIAL_SEGMENTS).fill(0);
    setBestSchedule(s); setBestSteering(st);
    setBestResult(simulateTrajectory(s, config, st));
  };

  return (
    <div className="w-full h-screen bg-[#0f172a] text-slate-200 font-sans overflow-hidden flex">
      <div className="w-80 bg-slate-900 border-r border-slate-700 flex flex-col z-10 shadow-xl flex-shrink-0">
          <div className="p-5 border-b border-slate-800">
              <h1 className="font-bold text-lg text-white tracking-tight flex items-center gap-2"><Layers className="text-blue-500"/> Cislunar AI</h1>
              <p className="text-[10px] text-slate-500 uppercase tracking-wider mt-1">Rotating Frame CR3BP Solver</p>
          </div>
          <div className="p-5 flex-1 overflow-y-auto">
              <div className="mb-6">
                  <h2 className="text-xs font-bold text-slate-400 uppercase tracking-wider mb-3 flex items-center gap-2"><MousePointer2 size={12}/> Scenarios</h2>
                  <div className="grid grid-cols-2 gap-2">
                      {Object.entries(MISSION_PRESETS).map(([key, val]) => (
                          <button key={key} onClick={() => {setConfig(val); handleReset();}} className="px-3 py-2 bg-slate-800 hover:bg-slate-700 border border-slate-700 rounded text-xs font-medium transition-colors text-left capitalize">{key.toLowerCase().replace('_', ' ')}</button>
                      ))}
                  </div>
              </div>
              <div className="h-px bg-slate-800 my-4"></div>
              <div className="mb-6">
                  <h2 className="text-xs font-bold text-blue-400 uppercase tracking-wider mb-4 flex items-center gap-2"><Settings size={14}/> Constraints</h2>
                  <SliderControl label="Dry Mass" value={config.mass} min={100} max={5000} step={100} unit="kg" onChange={(v) => setConfig(c => ({...c, mass: v}))} disabled={phase === 'RUNNING'} />
                  <SliderControl label="Max Thrust" value={config.thrust} min={0.1} max={5.0} step={0.1} unit="N" onChange={(v) => setConfig(c => ({...c, thrust: v}))} disabled={phase === 'RUNNING'} />
                  <SliderControl label="Isp" value={config.isp} min={1000} max={5000} step={100} unit="s" onChange={(v) => setConfig(c => ({...c, isp: v}))} disabled={phase === 'RUNNING'} />
                  <SliderControl label="Initial Altitude" value={config.initialRadius} min={500} max={10000} step={500} unit="km" onChange={(v) => setConfig(c => ({...c, initialRadius: v}))} disabled={phase === 'RUNNING'} />
              </div>
              <div className="p-4 bg-slate-800/50 rounded-lg border border-slate-700 text-xs text-slate-400">
                  <h3 className="font-bold text-slate-300 mb-2 flex justify-between"><span>AI Status</span><span className={phase === 'RUNNING' ? "text-blue-400 animate-pulse" : phase === 'CONVERGED' ? "text-green-400" : "text-slate-500"}>{phase === 'RUNNING' ? `GEN ${generation}` : phase}</span></h3>
                  <div className="space-y-1 font-mono">
                      <div className="flex justify-between"><span>Closest:</span><span className={bestResult?.closestDist < 3 ? "text-green-400" : "text-yellow-500"}>{bestResult?.closestDist.toFixed(2)} Mm</span></div>
                      <div className="flex justify-between"><span>Stable Orbits:</span><span className="text-white">{bestResult?.stableOrbits}</span></div>
                      <div className="mt-2 h-1.5 w-full bg-slate-700 rounded-full overflow-hidden"><div className="h-full bg-blue-500 transition-all duration-300" style={{ width: `${Math.min(100, (generation/200)*100)}%` }}></div></div>
                  </div>
              </div>
          </div>
      </div>
      <div className="flex-1 relative flex flex-col bg-black">
          <div className="flex-1 relative overflow-hidden">
              <Scene2D bestTrajectory={bestResult} ghostTrajectories={ghosts} />
              <div className="absolute top-6 left-6 flex flex-col gap-2 pointer-events-none">
                   {phase === 'RUNNING' && (
                     <div className="flex items-center gap-3 bg-slate-900/80 backdrop-blur px-4 py-3 rounded-lg border border-blue-500/30 shadow-xl">
                        <BrainCircuit size={24} className="text-blue-400 animate-pulse"/> 
                        <div><div className="text-blue-400 font-bold text-sm">CR3BP SOLVER RUNNING</div><div className="text-slate-400 text-[10px]">Rotating Frame (Coriolis + Centrifugal)</div></div>
                     </div>
                  )}
                  {bestResult?.captured && (
                     <div className="flex items-center gap-2 bg-green-900/80 backdrop-blur px-4 py-2 rounded-lg border border-green-500/50 shadow-lg animate-in fade-in slide-in-from-top-2">
                        <Orbit size={18} className="text-green-400"/> 
                        <div><div className="text-green-400 font-bold text-sm">STABLE CAPTURE</div><div className="text-green-200 text-[10px]">Target in Hill Sphere</div></div>
                     </div>
                  )}
              </div>
          </div>
          <div className="h-20 bg-slate-900 border-t border-slate-700 flex items-center px-8 gap-6 z-20 flex-shrink-0 justify-between">
               <div className="flex flex-col justify-center">
                   <div className="text-xs text-slate-500 font-bold mb-1">PHYSICS MODEL</div>
                   <div className="flex gap-2 text-[10px] text-slate-400">
                       <span className="px-2 py-1 bg-slate-800 rounded border border-slate-700">Rotating Frame</span>
                       <span className="px-2 py-1 bg-slate-800 rounded border border-slate-700">Genetic Alg</span>
                       <span className="px-2 py-1 bg-slate-800 rounded border border-slate-700">Coriolis</span>
                   </div>
               </div>
               <div className="flex items-center gap-4">
                   {phase === 'IDLE' || phase === 'CONVERGED' ? (
                       <button onClick={handleStart} className="flex items-center gap-2 px-8 py-3 bg-blue-600 hover:bg-blue-500 text-white rounded-lg font-bold shadow-lg shadow-blue-900/50 transition-all"><Zap size={18}/> START SOLVER</button>
                   ) : (
                       <button onClick={() => setPhase('IDLE')} className="flex items-center gap-2 px-8 py-3 bg-red-900/50 hover:bg-red-900 text-red-200 border border-red-800 rounded-lg font-bold transition-all">STOP</button>
                   )}
                   <button onClick={handleReset} className="p-3 bg-slate-800 hover:bg-slate-700 text-slate-400 rounded-lg border border-slate-700 transition-colors" title="Reset"><RefreshCw size={18}/></button>
               </div>
          </div>
      </div>
    </div>
  );
};

export default App;